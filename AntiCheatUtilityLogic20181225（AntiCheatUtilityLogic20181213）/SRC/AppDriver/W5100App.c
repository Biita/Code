/****************************************Copyright (c)****************************************************
**                         			BEIJING	WANJI(WJ)                               
**                                     
**
**--------------File Info---------------------------------------------------------------------------------
** File name:			W5100App.c
** Last modified Date:  20110622
** Last Version:		1.0
** Descriptions:		5100顶层驱动
**
**--------------------------------------------------------------------------------------------------------
** Modified by:			
** Modified date:		
** Version:
** Descriptions:
**
*********************************************************************************************************/
#define	__W5100APP_C
#include "W5100App.h"

static	NetInfo		m_sniLocal;		//本机网络信息
//static	uint8		m_au8NetBuf[W5100BUFSIZE];

#define W5100_Disable 	( P3_OUTP_CLR = ( 1 << 11 ) )			//W5100不使能
#define W5100_Enable	( P3_OUTP_SET = ( 1 << 11 ) )				//W5100使能
#define W5100_Reset()	W5100_Disable;W5100_Disable;W5100_Enable;	//W5100复位

/**********************************************************************
程序名: InitNetSetting
输入: m_sniLocal	本地网络参数
输出: 无
返回: 无
说明：设置网络参数设置
**********************************************************************/
void SetNetSetting(NetInfo p_sniLocal)
{
	memcpy(&m_sniLocal,&p_sniLocal,sizeof(m_sniLocal));
}
/**********************************************************************
程序名: ReadTargetSocktInfo
输入:	SOCKET s:	通信的连接号0~~~3
       
输出: pData	：  返回结构体，包含连接的状态，目标IP地址，目标端口号
返回: 无
说明：获取网络连接对端的IP信息
**********************************************************************/
void ReadTargetSocktInfo(SOCKET s,TargetIPInfo_Struct *pData)
{ 
 	//读状态
	pData->u8State = Read_W5100(W5100_S0_SSR+s*0x100);
	//读IP地址
	pData->u8CnntIP[0] = Read_W5100(W5100_S0_DIPR+s*0x100);
	pData->u8CnntIP[1] = Read_W5100(W5100_S0_DIPR+s*0x100 + 1);
	pData->u8CnntIP[2] = Read_W5100(W5100_S0_DIPR+s*0x100 + 2);
	pData->u8CnntIP[3] = Read_W5100(W5100_S0_DIPR+s*0x100 + 3);   
	//读端口号
  	pData->u8CnntPort[0] = Read_W5100(W5100_S0_DPORT+s*0x100);
	pData->u8CnntPort[1] = Read_W5100(W5100_S0_DPORT+s*0x100 + 1);

}
/**********************************************************************
程序名: InitNetSetting
输入: m_sniLocal	本地网络参数
输出: 无
返回: 无
说明：初始化网络参数 ，端口号，IP等
**********************************************************************/
void InitNetSetting(NetInfo *p_sniLocal)
{
	unsigned char i;
	
	for(i=0; i<4; i++)
	{
		Gateway_IP[i]	= p_sniLocal->au8GatewayIP[i];		// 加载网关参数
		Sub_Mask[i]		= p_sniLocal->au8SubMask[i];			// 加载子网掩码
		IP_Addr[i]		= p_sniLocal->au8IPAddr[i];			// 加载IP地址  
	}

	/* 加载物理地址 */
	for(i=0; i<6; i++)
		Phy_Addr[i] = p_sniLocal->au8MACAddr[i];

	//端口0
	S0_Port[0] = (p_sniLocal->u32LocalPortNO >> 8) & 0xFF;		//端口号
	S0_Port[1] = p_sniLocal->u32LocalPortNO & 0xFF;
	
	S0_State = 0;
//	for(i=0; i<4; i++)
//		S0_DIP[i]		= p_sniLocal->au8ServerIP[i];		// 目的IP地址

//	S0_DPort[0] = (p_sniLocal->u32ServerPortNO >> 8) & 0xFF;	 	//目的端口号
//	S0_DPort[1] = p_sniLocal->u32ServerPortNO & 0xFF;

	S0_Mode = TCP_SERVER;							//设置端口0默认的工作方式为TCP服务器模式

	//端口1
	S1_Port[0] = ((p_sniLocal->u32LocalPortNO+1) >> 8) & 0xFF;		//端口号
	S1_Port[1] = (p_sniLocal->u32LocalPortNO+1) & 0xFF;
	S1_State = 0;
//	for(i=0; i<4; i++)
//		S1_DIP[i]		= m_sniLocal.au8ServerIP[i];		// 目的IP地址

//	S1_DPort[0] = (m_sniLocal.u32ServerPortNO >> 8) & 0xFF;	 	//目的端口号
//	S1_DPort[1] = m_sniLocal.u32ServerPortNO & 0xFF;

	S1_Mode = TCP_SERVER;							//设置端口1默认的工作方式为TCP服务器模式 

	//端口2
	S2_Port[0] = ((p_sniLocal->u32LocalPortNO+2)>> 8) & 0xFF;		//端口号
	S2_Port[1] = (p_sniLocal->u32LocalPortNO+2)& 0xFF;
	S2_State = 0;
	for(i=0; i<4; i++)
		S2_DIP[i]		= p_sniLocal->au8ServerIP[i];		// 目的IP地址

	S2_DPort[0] = (p_sniLocal->u32ServerPortNO >> 8) & 0xFF;	 	//目的端口号
	S2_DPort[1] = p_sniLocal->u32ServerPortNO & 0xFF;

	S2_Mode = TCP_CLIENT;						//设置端口2默认的工作方式为TCP服务器 

	//端口3
	S3_Port[0] = ((p_sniLocal->u32LocalPortNO+3) >> 8) & 0xFF;		//端口号
	S3_Port[1] = (p_sniLocal->u32LocalPortNO+3) & 0xFF;
	S3_State = 0;
//	for(i=0; i<4; i++)
//		S3_DIP[i]		= m_sniLocal.au8ServerIP[i];		// 目的IP地址

//	S3_DPort[0] = (m_sniLocal.u32ServerPortNO >> 8) & 0xFF;	 	//目的端口号
//	S3_DPort[1] = m_sniLocal.u32ServerPortNO & 0xFF;

	S3_Mode = UDP_MODE;						//设置端口3默认的工作方式为TCP服务器 
}

/*****************************************************************
程序名: SetSocket
输入: 无
输出: 无
返回: 无
说明：分别设置4个端口，根据端口工作模式，将端口置于TCP服务器、TCP客户端
      或UDP模式。
      从端口状态字节Socket_State可以判断端口的工作情况
*****************************************************************/
void SetSocket(void)
 {
//	uint8 l_u8tempi;
	/* 端口 0 */
	if(S0_State==0)
	{
		if(S0_Mode==TCP_SERVER)			/* TCP服务器模式 */
		{
			if(Socket_Listen(0)==TRUE)
				S0_State=S_INIT;
			else
				S0_State=0;
		}
		else if(S0_Mode==TCP_CLIENT) 	/* TCP客户端模式 */
		{
			if(Socket_Connect(0)==TRUE)
				S0_State=S_INIT;
			else
				S0_State=0;
		}
		else							/* UDP模式 */
		{
			if(Socket_UDP(0)==TRUE)
				S0_State=S_INIT|S_CONN;
			else
				S0_State=0;
		}
	}

	/* 端口 1 */
	if(S1_State==0)
	{
		if(S1_Mode==TCP_SERVER)			/* TCP服务器模式 */
		{
			if(Socket_Listen(1)==TRUE)
				S1_State=S_INIT;
			else
				S1_State=0;
		}
		else if(S1_Mode==TCP_CLIENT)	/* TCP客户端模式 */
		{
			if(Socket_Connect(1)==TRUE)
				S1_State=S_INIT;
			else
				S1_State=0;
		}
		else							/* UDP模式 */
		{
			if(Socket_UDP(1)==TRUE)
				S1_State=S_INIT|S_CONN;
			else
				S1_State=0;
		}
	}

	/* 端口 2 */
	if(S2_State==0)
	{
		if(S2_Mode==TCP_SERVER)			/* TCP服务器模式 */
		{
			if(Socket_Listen(2)==TRUE)
				S2_State=S_INIT;
			else
				S2_State=0;
		}
		else if(S2_Mode==TCP_CLIENT) 	/* TCP客户端模式 */
		{
			if(Socket_Connect(2)==TRUE)
				S2_State=S_INIT;
			else
				S2_State=0;
		}
		else							/* UDP模式 */
		{
			if(Socket_UDP(2)==TRUE)
			S2_State=S_INIT|S_CONN;
			else
				S2_State=0;
		}
	}

	/* 端口 3 */
	if(S3_State==0)
	{
		if(S3_Mode==TCP_SERVER)			/* TCP服务器模式 */
		{
			if(Socket_Listen(3)==TRUE)
				S3_State=S_INIT;
			else
				S3_State=0;
		}
		else if(S3_Mode==TCP_CLIENT) 	/* TCP客户端模式 */
		{
			if(Socket_Connect(3)==TRUE)
				S3_State=S_INIT;
			else
				S3_State=0;
		}
		else							/* UDP模式 */
		{
			if(Socket_UDP(3)==TRUE)
			{
				S3_State=S_INIT|S_CONN;
					
//				S3_DIP[0]= 192; 
//				S3_DIP[1]= 168;
//				S3_DIP[2]= 3;
//				S3_DIP[3]= 24;
//				S3_DPort[0]=0x13;
//				S3_DPort[1]=0x88;
//				for(l_u8tempi=0;l_u8tempi<4;l_u8tempi++)
//					Write_W5100(W5100_S3_DIPR+l_u8tempi, S3_DIP[l_u8tempi]);
//				Write_W5100(W5100_S3_DPORT, S3_DPort[0]);
//				Write_W5100(W5100_S3_DPORT+1, S3_DPort[1]);
			}
			else
				S3_State=0;
		}
	}
}

/*****************************************************************
程序名: InitializeW5100
输入: 无
输出: 无
返回: 无
说明：先对W5100初始化，然后检查网关，最后分别初始化4个端口
*****************************************************************/
void InitializeW5100(NetInfo *p_sniLocal)
{
	//设置引脚
	P0_MUX_CLR = (1 << 1) | ( 1 << 0 );			//P0.0 P0.1 设置为P0.0 P0.1
	P0_DIR_CLR = (1 << 1) | ( 1 << 0 );			//P0.0 P0.1 设置为输入

	P2_MUX_CLR |= (1 << 5);						//GPIO_05 配置为 GPIO_05
	P2_DIR_CLR |= (1 << 30 );					//GPIO_05 设置为输入
	
	W5100_Reset();
	
//	SetNetSetting(p_sniLocal);
		
	InitNetSetting(p_sniLocal);

	W5100_Init();

	/* 检查网关服务器 */
//	Detect_Gateway();

	/* 端口0 */
	Socket_Init(0);

	/* 端口1 */
	Socket_Init(1);

	/* 端口2 */
	Socket_Init(2);

	/* 端口3 */
	Socket_Init(3);

	//开始监听
	SetSocket();

	SIC2_ER					|= (1 << 2);
	
	sic2IrqFuncSet(5	, 0	,(unsigned int)IRQ_W5100);      //中断引脚GPIO_02作为W5100中断信号  下降沿触发中断

}
/*********************************************************************************************************
** Function name:		SendDataNet
** Descriptions:		向网口发送数据
** input parameters:	p_u8SendBuf		发送数据指针 
** 						p_u32Len		发送数据长度
** output parameters:	发送数量
** Created by:			ZHANG Ye		  
** Created Date:		20110622	  
**-------------------------------------------------------------------------------------------------------
** Modified by:		
** Modified date:	
**-------------------------------------------------------------------------------------------------------
*********************************************************************************************************/
//uint32 SendDataNet(uint8 * p_u8SendBuf, uint32 p_u32Len)	  
uint32 SendDataNet(SOCKET p_s, uint8 * p_u8SendBuf, uint32 p_u32Len)
{
	uint8  	sk,state;
	uint32	l_u32SendSize = 0,ret = 0;
//	l_u32SendSize = (p_u32Len > W5100BUFSIZE) ? W5100BUFSIZE : p_u32Len;
		
	memcpy(Tx_Buffer, p_u8SendBuf, p_u32Len);
	//for(sk = 0;sk<4;sk++)
	sk = p_s;
	{
		state = Read_W5100(W5100_S0_SSR+sk*0x100);
		if(state == S_SSR_ESTABLISHED || state == S_SSR_UDP)
		{
			ret = S_tx_process(sk, p_u32Len);	
			ret ? l_u32SendSize = p_u32Len : 0;	  
		} 
	}	
	return l_u32SendSize;
}

//W5100中断处理
void IRQ_W5100(void)
{
	
	#define BUFRECSIZE	1000
	uint16	l_u16DataSize;
	uint8   l_u8tempi;
	//uint16	l_u16ID;
	//uint8	ret;

//	OSIntEnter();
	W5100_Interrupt = 1;
	W5100_Interrupt_Process();				//中断方式
	
	//return ;
	/* 如果Socket0接收到数据 */
	if((S0_Data & S_RECEIVE) == S_RECEIVE)
	{
		S0_Data	&= ~S_RECEIVE;
		
	//	l_u16DataSize = S_rx_process(0)-8;	  //UDP协议，前8字节为物理层数据，对用户为无效字节
		l_u16DataSize = S_rx_process(0);		 // 20121107
		if (l_u16DataSize > 0)
		{
			if( 0 != CheckCrc( Rx_Buffer, l_u16DataSize-2) )	   // 增加CRC校验，wujinlong 20130911
			{
				memcpy(g_anfSPIAD[g_u8NetADIn], Rx_Buffer, l_u16DataSize);	   //20121107
				g_u8NetADIn	++;
				g_u8NetADIn %= NETDATA_BUFMASK;	
				g_u16NetADcount	++;
				g_u16NetADcount %= NETDATA_BUFMASK;
			}
			
		}  
//		g_u8DeviceERR		&= 0xef;
		g_u8NetStatusErr	= 0;
	}
  	if((S1_Data & S_RECEIVE) == S_RECEIVE)
	{
		S1_Data	&= ~S_RECEIVE;	 		
		l_u16DataSize = S_rx_process(1);		 // 20121107
		if (l_u16DataSize > 0)
		{
			memcpy(g_anfSPIAD[g_u8NetADIn], Rx_Buffer, l_u16DataSize);	   //20121107
			g_u8NetADIn	++;
			g_u8NetADIn %= NETDATA_BUFMASK;	
			g_u16NetADcount	++;
			g_u16NetADcount %= NETDATA_BUFMASK;
		}  
		g_u8NetStatusErr	= 0;
	}
	if((S2_Data & S_RECEIVE) == S_RECEIVE)
	{
		S2_Data	&= ~S_RECEIVE;
		

		l_u16DataSize = S_rx_process(2);		 // 20121107
		if (l_u16DataSize > 0)
		{
			memcpy(g_anfSPIAD[g_u8NetADIn], Rx_Buffer, l_u16DataSize);	   //20121107
			g_u8NetADIn	++;
			g_u8NetADIn %= NETDATA_BUFMASK;	
			g_u16NetADcount	++;
			g_u16NetADcount %= NETDATA_BUFMASK;
		}  
		g_u8NetStatusErr	= 0;
	}

	//
   	if((S3_Data & S_RECEIVE) == S_RECEIVE)
	{
		S3_Data	&= ~S_RECEIVE;
		
		l_u16DataSize = S_rx_process(3)-8;		 // 20121107
		for(l_u8tempi=0; l_u8tempi<4; l_u8tempi++)
		{	
			S3_DIP[l_u8tempi]= Rx_Buffer[l_u8tempi]; 
		}
		S3_DPort[0]=Rx_Buffer[4];
		S3_DPort[1]=Rx_Buffer[5];
		for(l_u8tempi=0;l_u8tempi<4;l_u8tempi++)
			Write_W5100(W5100_S3_DIPR+l_u8tempi, S3_DIP[l_u8tempi]);
		Write_W5100(W5100_S3_DPORT, S3_DPort[0]);
		Write_W5100(W5100_S3_DPORT+1, S3_DPort[1]);
		if (l_u16DataSize > 0)
		{
			memcpy(g_anfSPIAD[g_u8NetADIn], &Rx_Buffer[8], l_u16DataSize);	   //20121107
			g_u8NetADIn	++;
			g_u8NetADIn %= NETDATA_BUFMASK;	
			g_u16NetADcount	++;
			g_u16NetADcount %= NETDATA_BUFMASK;
		}  
		g_u8NetStatusErr	= 0;
	}

//	OSIntExit();
}

